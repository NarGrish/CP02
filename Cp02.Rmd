---
title: 'Übung 02: Verfahrens- und Maschinenfehler'
author: "Tobias Blesgen und Leonardo Thome"
date: "19.05.2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes: 
 - \usepackage{amssymb}
 - \usepackage{amsmath}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Im folgenden wollen wir die 2-Punktformel und 3-Punktformel auf ihre Verfahrensfehler untersuchen und durch Verwendung verschiedener Datentypen den Maschienfehler abschätzen.

Die 2-Punktformel beschreibt die Ableitung einer Funktion $f(x)$ an der Stelle $x_i$ mit:
  \begin{equation}
    f'(x_i) = \frac{f(x_{i+1})-f(x_i)}{h} + O(h) 
  \end{equation}
  
Die 3-Punktformel tut dies hingegen mit einem kleineren Verfahrensfehler der Ordnung $O(h^2)$
  \begin{equation}
    f'(x_i) = \frac{f(x_{i+1})-f(x_{i-1})}{2h} + O(h^2) 
  \end{equation}



# Verfahrens- und Maschinenfehler

## Maschinenfehler

Da wir Zahlen am Computer nur endliche Stellen haben, geschiehen Rundungsfehler bei Berechnung von Zahlen die mehr Stellen besitzen als der benutzte Typ.
Diese Genauigkeit nennen wir Maschiengenauigkeit $\delta_M$ und ist definiert über die größte reelle Zahl $\delta_M$, so dass der Rechner noch $1 +  \delta_M = 1$ berechnet (Seite 12 /cite{DeltaM}).

## Verfahrensfehler

## Beispiel Anhand der Differentation

### Der 2-Punkt Ansatz

Am Beispiel der Differentation der Funktion $f(x) = e^x$ an der Stelle x = -1 sollen die Fehlertypen aufgezeigt werden. Wir betrachten zuerst die 2-Punktformel und den Unterschied zwischen einem Ansatz, der ``Double`` und einem, der ``Floats`` verwendet. Da der Code bis auf den Typwechsel identisch ist, liegt hier nur der Double-Code vor: 

```{Rcpp}
#include <Rcpp.h>
#include <math.h>

using namespace Rcpp;

//[[Rcpp::export]]
Rcpp::List diff2PunktDouble(const double x, const int r){
  // Array der ersten 100 Werte:
    Rcpp::NumericVector xValue(100);
    Rcpp::NumericVector yValue(100);
  // Quelltext
    for (int i = r; i<=99+r; i++){
      xValue[i-r] = 1./i;
      yValue[i-r] = (exp(x+1./i) - exp(x))/(1./i);
    }
  // Rückgabe für eine grafische Wiedergabe
    return List::create(Named("x") = xValue, Named("y") = yValue);
}
```

```{Rcpp,echo=FALSE}
#include <Rcpp.h>
#include <math.h>

using namespace Rcpp;

//[[Rcpp::export]]
Rcpp::List diff2PunktFloat(const float x, const int r){
  // Array der ersten 100 Werte:
    Rcpp::NumericVector xValue(100);
    Rcpp::NumericVector yValue(100);
  // Quelltext
    for (int i = r; i<=99+r; i++){
      xValue[i-r] = (float)1./i;
      yValue[i-r] = (float)(exp(x+1./i) - exp(x))/(1./i);
    }
  // Rückgabe für eine grafische Wiedergabe
    return List::create(Named("x") = xValue, Named("y") = yValue);
}
```



```{r, echo=FALSE}
x = -1
r1 = 1
r2 = 450
double2 = diff2PunktDouble(x, r1)
float2 = diff2PunktFloat(x, r1)
double2a = diff2PunktDouble(x, r2)
float2a = diff2PunktFloat(x, r2)
```

```{r, echo=FALSE}
e1 = exp(-1)

plot(double2$x, double2$y-e1, "l", log="xy", xlab = "h", ylab = "Gesamtfehler", col = "dark blue")
lines(float2$x, float2$y-e1, "l", col = "green")
legend(0.01,0.2,legend=c("2 Punkt Double", "2 Punkt Float"), col = c("dark blue", "green"), lty=1:1)

plot(double2a$x, double2a$y-e1, "l", log="xy", xlab = "h", ylab = "Gesamtfehler", col = "dark blue")
lines(float2a$x, float2a$y-e1, "l", col = "green")
legend(0.00182,0.000405,legend=c("2 Punkt Double", "2 Punkt Float"), col = c("dark blue", "green"), lty=1:1)
```

Während für h in der Größenortnung 1 bis 0,01 keine sichtbaren Differenzen zwischen den Gesammtfehlern hervorruft, kann in der nächst kleineren Größerenordnung eine Divergenz der beiden Fehlergrößen beobachtet werden.

### Der 3-Punkt Ansatz

Um das 2-Punktverfahren auch mit einem anderen Verfahren vergleichen zu können, verwenden wir das 3-Punktverfahren. Erneut implementieren wir es einmal mit ``Double`` und einmal mit ``Float``-Precision.

```{Rcpp}
#include <Rcpp.h>
#include <math.h>

using namespace Rcpp;

//[[Rcpp::export]]
Rcpp::List diff3PunktDouble(const double x, const int r){
  // Array der ersten 100 Werte:
    Rcpp::NumericVector xValue(100);
    Rcpp::NumericVector yValue(100);
  // Quelltext
    for (int i = r; i<=99+r; i++){
      xValue[i-r] = 1./i;
      yValue[i-r] = (exp(x+1./i) - exp(x-1./i))/(2./i);
    }
  // Rückgabe für eine grafische Wiedergabe
    return List::create(Named("x") = xValue, Named("y") = yValue);
}
```

```{Rcpp,echo=FALSE}
#include <Rcpp.h>
#include <math.h>

using namespace Rcpp;

//[[Rcpp::export]]
Rcpp::List diff3PunktFloat(const float x, const int r){
  // Array der ersten 100 Werte:
    Rcpp::NumericVector xValue(100);
    Rcpp::NumericVector yValue(100);
  // Quelltext
    for (int i = r; i<=99+r; i++){
      xValue[i-r] = (float)1./i;
      yValue[i-r] = (float)(exp(x+1./i) - exp(x-1./i))/(2./i);
    }
  // Rückgabe für eine grafische Wiedergabe
    return List::create(Named("x") = xValue, Named("y") = yValue);
}
```

Trägt man nun die beiden Graphen grafisch auf so findet man für h's bei um die 0,005 die ersten Auffälligen Unterschiede:

```{r, echo=FALSE}
x = -1
r = 200
r2 = 300
double3a = diff3PunktDouble(x, r)
float3a = diff3PunktFloat(x, r)

double3b = diff3PunktDouble(x, r2)
float3b = diff3PunktFloat(x, r2)
```

```{r, echo=FALSE}
e1 = exp(-1)
plot(double3a$x, double3a$y-e1, "l", log="xy", xlab = "h", ylab = "Gesamtfehler", col = "red")
lines(float3a$x, float3a$y-e1, "l", col = "orange")
legend(0.00335,0.0000015,legend=c("3 Punkt Double", "3 Punkt Float"), col = c("red", "orange"), lty=1:1)

plot(double3b$x, double3b$y-e1, "l", log="xy", xlab = "h", ylab = "Gesamtfehler", col = "red")
lines(float3b$x, float3b$y-e1, "l", col = "orange")
legend(0.00182,3.0e-07,legend=c("3 Punkt Double", "3 Punkt Float"), col = c("red", "orange"), lty=1:1)
```
Während der ``Double``-Graph eine glatte Gerade beschreibt, springt der ``Float``-Graph wahllos wirkend über und unter diese Gerade. Dieses Zittern wird mit sinkenden h immer extremer und verdeutlicht, dass die Unterschiede der Näherungswerte die Größenordnung des Maschinenfehlers erreichen. Um diese Zitterbewegung auch am ``Float``-Graphen zu entdecken, muss das h in der Größenordnung von $10^{-4}$ betrachtet werden.

```{r, echo=FALSE}
x = -1
r = 1
double2b = diff2PunktDouble(x, r)
double3b = diff3PunktDouble(x, r)

```

```{r, echo=FALSE}
e1 = exp(-1)
plot(double2b$x, double2b$y-e1, "l", ylim=c(double3b$y[99]-e1, double2b$y[1]-e1), xlab = "h", log="xy", ylab = "Gesamtfehler", col = "dark blue")
lines(double3b$x, double3b$y-e1, "l", col = "red")

legend(0.01,0.198,legend=c("2 Punkt Double", "3 Punkt Double"), col = c("dark blue", "red"), lty=1:1)
```


\begin{thebibliography}{99}
\bibitem{DeltaM} 
C. Urbach, \textit{Vorlesungsskript Computerphysiks},Seite 12,2021.

\end{thebibliography}

